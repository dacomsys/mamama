<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>간단한 벽돌깨기 게임</title>
<style>
  /* CSS: 게임 캔버스의 스타일링 
    HTML <style> 태그 내부에 포함됩니다.
  */
  body { 
    background: #eee; 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    height: 100vh; 
    margin: 0; 
  }
  #myCanvas { 
    background: #000; 
    display: block; 
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  }
</style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
  /*
    JavaScript: 게임 로직 
    HTML <script> 태그 내부에 포함됩니다.
  */
  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");

  // --- 공(Ball) 설정 ---
  let ballRadius = 6;
  let x = canvas.width / 2; // 공의 x 좌표
  let y = canvas.height - 30; // 공의 y 좌표
  let dx = 2; // 공의 x 방향 속도
  let dy = -2; // 공의 y 방향 속도

  // --- 패들(Paddle) 설정 ---
  const paddleHeight = 10;
  const paddleWidth = 75;
  let paddleX = (canvas.width - paddleWidth) / 2; // 패들의 x 좌표

  // --- 키보드 입력 설정 ---
  let rightPressed = false;
  let leftPressed = false;

  // --- 벽돌(Bricks) 설정 ---
  const brickRowCount = 3; // 벽돌 행 수
  const brickColumnCount = 5; // 벽돌 열 수
  const brickWidth = 75;
  const brickHeight = 20;
  const brickPadding = 10;
  const brickOffsetTop = 30;
  const brickOffsetLeft = 30;

  let bricks = [];
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      // status: 1 (존재), 0 (파괴됨)
      bricks[c][r] = { x: 0, y: 0, status: 1 }; 
    }
  }

  // --- 점수 및 생명 설정 ---
  let score = 0;
  let lives = 3;

  // --- 이벤트 리스너: 키보드 입력 처리 ---
  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);
  document.addEventListener("mousemove", mouseMoveHandler, false); // 마우스 이동 추가

  function keyDownHandler(e) {
    if (e.key === "Right" || e.key === "ArrowRight") {
      rightPressed = true;
    } else if (e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed = true;
    }
  }

  function keyUpHandler(e) {
    if (e.key === "Right" || e.key === "ArrowRight") {
      rightPressed = false;
    } else if (e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed = false;
    }
  }

  function mouseMoveHandler(e) {
    const relativeX = e.clientX - canvas.offsetLeft;
    if (relativeX > 0 && relativeX < canvas.width) {
      // 캔버스 중앙에 마우스 위치를 기준으로 패들 위치 설정
      paddleX = relativeX - paddleWidth / 2; 
      if (paddleX < 0) {
        paddleX = 0;
      }
      if (paddleX > canvas.width - paddleWidth) {
        paddleX = canvas.width - paddleWidth;
      }
    }
  }

  // --- 그리기 함수 ---

  function drawBall() {
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        if (bricks[c][r].status === 1) { // 벽돌이 살아있으면 그림
          const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          ctx.fillStyle = "#FF4500"; // 주황색 벽돌
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function drawScore() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FFFFFF"; // 흰색 글씨
    ctx.fillText("점수: " + score, 8, 20);
  }

  function drawLives() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FFFFFF"; // 흰색 글씨
    ctx.fillText("생명: " + lives, canvas.width - 65, 20);
  }

  // --- 충돌 감지 로직 ---
  function collisionDetection() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        const b = bricks[c][r];
        if (b.status === 1) {
          // 공이 벽돌의 경계 안에 있으면 충돌!
          if (
            x > b.x &&
            x < b.x + brickWidth &&
            y > b.y &&
            y < b.y + brickHeight
          ) {
            dy = -dy; // 공의 방향을 반전
            b.status = 0; // 벽돌 파괴
            score++; // 점수 증가

            // 모든 벽돌을 깼는지 확인
            if (score === brickRowCount * brickColumnCount) {
              alert("축하합니다! 게임 승리!");
              document.location.reload(); // 게임 재시작
            }
          }
        }
      }
    }
  }

  // --- 메인 드로우 함수 (게임 루프) ---
  function draw() {
    // 이전 프레임 지우기
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 요소 그리기 및 업데이트
    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    drawLives();
    collisionDetection();

    // --- 공의 움직임 업데이트 ---
    x += dx;
    y += dy;

    // 벽 충돌 (좌/우)
    if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
      dx = -dx;
    }

    // 벽 충돌 (상단)
    if (y + dy < ballRadius) {
      dy = -dy;
    } 
    // 벽 충돌 (하단 - 패들 미스)
    else if (y + dy > canvas.height - ballRadius) {
      // 패들에 맞았는지 확인
      if (x > paddleX && x < paddleX + paddleWidth) {
        dy = -dy; // 패들에 맞으면 튕겨냄
      } else {
        // 패들 미스: 생명 감소 및 리셋
        lives--;
        if (!lives) {
          alert("게임 오버");
          document.location.reload(); // 게임 재시작
        } else {
          // 공과 패들 리셋
          x = canvas.width / 2;
          y = canvas.height - 30;
          dx = 2;
          dy = -2;
          paddleX = (canvas.width - paddleWidth) / 2;
        }
      }
    }

    // --- 패들 움직임 업데이트 (키보드) ---
    if (rightPressed && paddleX < canvas.width - paddleWidth) {
      paddleX += 7;
    } else if (leftPressed && paddleX > 0) {
      paddleX -= 7;
    }

    // 다음 프레임 요청
    requestAnimationFrame(draw);
  }

  // 게임 시작
  draw();
</script>

</body>
</html>